# Gu√≠a de Migraci√≥n: MySQL ‚Üí Oracle Database

Esta gu√≠a proporciona una referencia r√°pida para adaptar c√≥digo PHP de MySQL a Oracle Database.

## üìã Tabla de Comparaci√≥n: Tipos de Datos

| MySQL | Oracle | Notas |
|-------|--------|-------|
| `INT`, `INTEGER` | `NUMBER` | Oracle usa NUMBER para todos los enteros |
| `TINYINT(1)` | `NUMBER(1)` | Para booleanos (0/1) |
| `BIGINT` | `NUMBER(19)` | Enteros grandes |
| `DECIMAL(p,s)` | `NUMBER(p,s)` | Precisi√≥n decimal |
| `FLOAT`, `DOUBLE` | `BINARY_FLOAT`, `BINARY_DOUBLE` | N√∫meros flotantes |
| `VARCHAR(n)` | `VARCHAR2(n)` | Cadenas de texto variables |
| `CHAR(n)` | `CHAR(n)` | Cadenas de texto fijas |
| `TEXT` | `CLOB` | Texto largo |
| `BLOB` | `BLOB` | Datos binarios |
| `DATE` | `DATE` | Solo fecha en MySQL, fecha+hora en Oracle |
| `DATETIME` | `TIMESTAMP` | Fecha y hora |
| `TIME` | `INTERVAL` o `TIMESTAMP` | Duraci√≥n temporal |
| `ENUM('a','b')` | `VARCHAR2 + CHECK` | Oracle no tiene ENUM nativo |
| `AUTO_INCREMENT` | `IDENTITY` o `SEQUENCE` | Auto-incremento |

## üîß Funciones Comunes

### Funciones de Fecha y Hora

```sql
-- MySQL
SELECT NOW();
SELECT CURDATE();
SELECT DATE_FORMAT(fecha, '%d/%m/%Y');
SELECT YEAR(fecha), MONTH(fecha), DAY(fecha);

-- Oracle
SELECT SYSDATE FROM DUAL;
SELECT TRUNC(SYSDATE) FROM DUAL;
SELECT TO_CHAR(fecha, 'DD/MM/YYYY') FROM DUAL;
SELECT EXTRACT(YEAR FROM fecha), EXTRACT(MONTH FROM fecha), EXTRACT(DAY FROM fecha) FROM DUAL;
```

### Funciones de Cadena

```sql
-- MySQL
SELECT CONCAT(nombre, ' ', apellido);
SELECT UPPER(nombre);
SELECT LOWER(nombre);
SELECT LENGTH(texto);
SELECT SUBSTRING(texto, 1, 10);

-- Oracle
SELECT nombre || ' ' || apellido FROM DUAL;  -- o CONCAT(nombre, apellido)
SELECT UPPER(nombre) FROM DUAL;
SELECT LOWER(nombre) FROM DUAL;
SELECT LENGTH(texto) FROM DUAL;
SELECT SUBSTR(texto, 1, 10) FROM DUAL;
```

### Funciones Condicionales

```sql
-- MySQL
SELECT IF(condicion, 'verdadero', 'falso');
SELECT IFNULL(columna, 'valor_default');
SELECT COALESCE(col1, col2, 'default');

-- Oracle
SELECT CASE WHEN condicion THEN 'verdadero' ELSE 'falso' END FROM DUAL;
SELECT NVL(columna, 'valor_default') FROM DUAL;
SELECT COALESCE(col1, col2, 'default') FROM DUAL;
```

## üìä Consultas SELECT

### LIMIT / Paginaci√≥n

```sql
-- MySQL
SELECT * FROM usuarios LIMIT 10;
SELECT * FROM usuarios LIMIT 10 OFFSET 20;

-- Oracle 12c+
SELECT * FROM usuarios FETCH FIRST 10 ROWS ONLY;
SELECT * FROM usuarios OFFSET 20 ROWS FETCH NEXT 10 ROWS ONLY;
```

### B√∫squedas Case-Insensitive

```sql
-- MySQL (depende de collation)
SELECT * FROM usuarios WHERE nombre LIKE '%carlos%';

-- Oracle (case-sensitive por defecto)
SELECT * FROM usuarios WHERE UPPER(nombre) LIKE UPPER('%carlos%');
-- o usar REGEXP_LIKE para b√∫squedas m√°s complejas
SELECT * FROM usuarios WHERE REGEXP_LIKE(nombre, 'carlos', 'i');
```

## üîë Auto-incremento e Identidad

### MySQL

```sql
CREATE TABLE usuarios (
    id INT AUTO_INCREMENT PRIMARY KEY,
    nombre VARCHAR(100)
);

INSERT INTO usuarios (nombre) VALUES ('Juan');
SELECT LAST_INSERT_ID();
```

### Oracle

```sql
CREATE TABLE usuarios (
    id NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
    nombre VARCHAR2(100)
);

INSERT INTO usuarios (nombre) VALUES ('Juan');
-- Obtener √∫ltimo ID:
SELECT MAX(id) FROM usuarios;
-- o en PHP:
-- $lastId = OracleHelper::getLastInsertId($pdo, 'usuarios');
```

## üîÑ INSERT, UPDATE, DELETE

### INSERT

```sql
-- MySQL y Oracle (similar)
INSERT INTO usuarios (nombre, email) VALUES ('Juan', 'juan@example.com');

-- INSERT m√∫ltiple
-- MySQL
INSERT INTO usuarios (nombre, email) VALUES 
    ('Juan', 'juan@example.com'),
    ('Mar√≠a', 'maria@example.com');

-- Oracle (usar INSERT ALL)
INSERT ALL
    INTO usuarios (nombre, email) VALUES ('Juan', 'juan@example.com')
    INTO usuarios (nombre, email) VALUES ('Mar√≠a', 'maria@example.com')
SELECT * FROM DUAL;
```

### UPDATE

```sql
-- MySQL y Oracle (similar)
UPDATE usuarios SET nombre = 'Juan Carlos' WHERE id = 1;
```

### DELETE

```sql
-- MySQL y Oracle (similar)
DELETE FROM usuarios WHERE id = 1;
```

## üîó JOINs

```sql
-- MySQL y Oracle (sintaxis similar)
SELECT u.nombre, e.nombre_evento
FROM usuarios u
INNER JOIN inscripciones i ON u.id_usuario = i.id_usuario
INNER JOIN eventos e ON i.id_evento = e.id_evento;
```

## üìù C√≥digo PHP: Diferencias en PDO

### Conexi√≥n

```php
// MySQL
$dsn = "mysql:host=localhost;dbname=congreso_db;charset=utf8mb4";
$pdo = new PDO($dsn, $user, $pass);

// Oracle
$dsn = "oci:dbname=//localhost:1521/FREEPDB1;charset=AL32UTF8";
$pdo = new PDO($dsn, $user, $pass);
```

### Prepared Statements

```php
// Ambos usan la misma sintaxis
$stmt = $pdo->prepare("SELECT * FROM usuarios WHERE email = :email");
$stmt->execute([':email' => $email]);
$usuario = $stmt->fetch(PDO::FETCH_ASSOC);
```

### √öltimo ID Insertado

```php
// MySQL
$id = $pdo->lastInsertId();

// Oracle
// Opci√≥n 1: Consultar el m√°ximo ID
$id = OracleHelper::getLastInsertId($pdo, 'usuarios');

// Opci√≥n 2: Usar RETURNING en el INSERT
$stmt = $pdo->prepare("
    INSERT INTO usuarios (nombre, email) 
    VALUES (:nombre, :email) 
    RETURNING id_usuario INTO :id
");
$id = null;
$stmt->bindParam(':id', $id, PDO::PARAM_INT, 10);
$stmt->execute([':nombre' => $nombre, ':email' => $email]);
```

### Booleanos

```php
// MySQL
$activo = true;
$stmt->execute([':activo' => $activo]); // Se convierte autom√°ticamente

// Oracle (usar 0/1)
$activo = true;
$stmt->execute([':activo' => OracleHelper::fromBoolean($activo)]);

// Al leer
$activo = OracleHelper::toBoolean($row['activo']);
```

## üéØ Ejemplos de Migraci√≥n de Consultas Comunes

### Ejemplo 1: B√∫squeda con Paginaci√≥n

```php
// MySQL
$sql = "SELECT * FROM usuarios WHERE nombre LIKE :search ORDER BY nombre LIMIT :limit OFFSET :offset";
$stmt = $pdo->prepare($sql);
$stmt->bindValue(':search', "%$busqueda%", PDO::PARAM_STR);
$stmt->bindValue(':limit', $perPage, PDO::PARAM_INT);
$stmt->bindValue(':offset', $offset, PDO::PARAM_INT);

// Oracle
$sql = "SELECT * FROM usuarios 
        WHERE UPPER(nombre) LIKE UPPER(:search) 
        ORDER BY nombre 
        OFFSET :offset ROWS FETCH NEXT :limit ROWS ONLY";
$stmt = $pdo->prepare($sql);
$stmt->bindValue(':search', "%$busqueda%", PDO::PARAM_STR);
$stmt->bindValue(':limit', $perPage, PDO::PARAM_INT);
$stmt->bindValue(':offset', $offset, PDO::PARAM_INT);
```

### Ejemplo 2: Obtener Registros con Fecha Formateada

```php
// MySQL
$sql = "SELECT id, nombre, DATE_FORMAT(fecha_registro, '%d/%m/%Y %H:%i') as fecha 
        FROM usuarios";

// Oracle
$sql = "SELECT id_usuario, nombre, 
        TO_CHAR(fecha_registro, 'DD/MM/YYYY HH24:MI') as fecha 
        FROM usuarios";
```

### Ejemplo 3: Conteo de Registros Relacionados

```php
// MySQL y Oracle (similar)
$sql = "SELECT e.nombre_evento, COUNT(i.id_inscripcion) as total_inscritos
        FROM eventos e
        LEFT JOIN inscripciones i ON e.id_evento = i.id_evento
        WHERE i.estado = 'Inscrito'
        GROUP BY e.id_evento, e.nombre_evento
        ORDER BY total_inscritos DESC";
```

## ‚ö†Ô∏è Consideraciones Importantes

### 1. Case Sensitivity
- **MySQL**: Case-insensitive por defecto (depende de collation)
- **Oracle**: Case-sensitive. Usa `UPPER()` o `LOWER()` para b√∫squedas

### 2. NULL vs Cadena Vac√≠a
- **MySQL**: Distingue entre NULL y ''
- **Oracle**: Trata '' como NULL

### 3. Nombres de Columnas
- **MySQL**: Devuelve nombres tal como est√°n en la consulta
- **Oracle**: Convierte a MAY√öSCULAS por defecto
- **Soluci√≥n**: Usar `PDO::ATTR_CASE => PDO::CASE_LOWER` en opciones de PDO

### 4. Transacciones
```php
// Ambos usan la misma sintaxis
try {
    $pdo->beginTransaction();
    // ... ejecutar queries
    $pdo->commit();
} catch (PDOException $e) {
    $pdo->rollBack();
    throw $e;
}
```

### 5. Comillas en SQL
- **MySQL**: Acepta comillas simples (') y dobles (") para strings
- **Oracle**: Solo comillas simples (') para strings, dobles (") para identificadores

## üõ†Ô∏è Herramientas √ötiles

### Funciones Helper Creadas

```php
// En oracle_helpers.php
OracleHelper::convertLimit($sql, $limit, $offset)
OracleHelper::getLastInsertId($pdo, 'tabla')
OracleHelper::toBoolean($value)
OracleHelper::fromBoolean($value)
OracleHelper::formatDate($date, 'd/m/Y H:i')
OracleHelper::escapeLike($string)
OracleHelper::buildLikeClause($column, $value)
OracleHelper::tableExists($pdo, 'tabla')
OracleHelper::getRecordCount($pdo, 'tabla', 'WHERE ...')
```

### Uso en C√≥digo

```php
// Incluir helpers
require_once 'php/oracle_helpers.php';

// Usar funciones
$id = oracle_last_insert_id($pdo, 'usuarios');
$activo = oracle_bool($row['activo']);
$fecha = oracle_format_date($row['fecha_registro']);
```

## üìö Recursos Adicionales

- [Oracle SQL Language Reference](https://docs.oracle.com/en/database/oracle/oracle-database/23/sqlrf/)
- [PHP PDO_OCI Documentation](https://www.php.net/manual/en/ref.pdo-oci.php)
- [Oracle to MySQL Migration Guide](https://www.oracle.com/database/technologies/migration.html)

---

**√öltima actualizaci√≥n**: 8 de Noviembre, 2025
